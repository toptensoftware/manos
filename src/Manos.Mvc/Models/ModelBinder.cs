using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;

namespace Manos.Mvc
{
	public class ModelBinder
	{
		public ModelBinder(ModelState state)
		{
			this.ModelState = state;
		}

		ModelState ModelState
		{
			get;
			set;
		}


		ModelValue GetModelValue(string key, IModelValueProvider provider, PropertyInfo pi)
		{
			// Get the model value
			var string_value = provider.GetValue(key);
			if (string_value == null)
				return null;

			// Create the model value entry
			var mv = new ModelValue();
			mv.Name = key;
			mv.InputValue = string_value;

			// Convert to required type
			if (pi.PropertyType != typeof(string))
			{
				try
				{
					mv.ConvertedValue = Convert.ChangeType(string_value, pi.PropertyType);
				}
				catch (Exception x)
				{
					mv.Errors.Add(new ModelStateError(pi.Name, string.Format("Can't convert '{0}' to {1} - {2}", string_value, pi.PropertyType.FullName, x.Message)));
				}
			}
			else
			{
				mv.ConvertedValue = string_value;
			}

			return mv;
		}

		void BindField(string key, IModelValueProvider provider, object model, PropertyInfo pi)
		{
			// Get converted value
			var mv = GetModelValue(key, provider, pi);
			if (mv == null)
				return;

			// Add to our collection of model values
			ModelState.Values.Add(mv.Name, mv);

			// Copy over errors too
			foreach (var e in mv.Errors)
			{
				ModelState.Errors.Add(e);
			}

			// Apply the property value
			if (mv.IsValid)
			{
				// Save the original value
				mv.OriginalValue = pi.GetValue(model, null);

				// Apply the new value
				pi.SetValue(model, mv.ConvertedValue, null);
			}
		}

		public string[] ExcludeFields
		{
			get;
			set;
		}

		public string[] IncludeFields
		{
			get;
			set;
		}

		string[] BuildFieldList(IModelValueProvider provider, object model)
		{
			string[] fields = null;

			// If an include list was passed, try to get it from the provider
			// The HttpModelValueProvider uses the hidden field generated by the form
			// to build a list of valid fields for binding
			if (IncludeFields == null)
			{
				fields = provider.GetFieldList(model);
			}

			// If an exclude list was specified, apply it now
			if (ExcludeFields != null)
			{
				// If we don't have an include list, start with the full list of properties on the model
				if (fields == null)
					fields = (from pi in model.GetType().GetProperties() select pi.Name).ToArray();

				// Exclude specified fields
				fields = (from f in fields where !ExcludeFields.Contains(f) select f).ToArray();
			}

			// Return the final field list
			return fields;
		}

		public static bool ResolveField(object model, string key, out object target, out PropertyInfo pi)
		{
			// For now we just lookup properties directly on the model (no depth search)
			pi = model.GetType().GetProperty(key);
			if (pi!=null)
			{
				target = model;
				return true;
			}

			// Not found
			target = null;
			return false;
		}


		public bool TryUpdateModel(IModelValueProvider provider, object model)
		{
			// Build the list of fields to be updated
			string[] field_list = BuildFieldList(provider, model);
			if (field_list == null)
			{
				throw new InvalidOperationException("Can't bind model as value provider can't provide a valid list of fields and neither an include nor exclude list was provided");
			}

			// Update all property values
			foreach (var f in field_list)
			{
				// Find the target property
				object target;
				PropertyInfo pi;
				if (!ResolveField(model, f, out target, out pi))
				{
					throw new InvalidOperationException(string.Format("Can't bind field `{0}` to model of type `{1}`", f, model.GetType().FullName));
				}

				// Apply it's value
				BindField(f, provider, target, pi);
			}

			return ModelState.IsValid;
		}
	}
}
